<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title></title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
		html {
			width:100%;
			height: 100%;
			overflow:hidden;
		}

		body {
			margin: 0;
			min-height: 100%;
		}

		.zdog-canvas {
position:absolute;
			width:100%;
			height:100%;
			background:#FDB;
			cursor: crosshair;
		}

#konsoli {
font-family:monospace;
font-size:8;
position:absolute;
pointer-events:none;
z-index:999;
width:100%;
white-space:pre;

}
.clearButton {
position:absolute;
width:40px;
height:40px;
right:0;
bottom:0;
background:#FFF;
}
		</style>

		<script src="js/zdog.dist.min.js"></script>
		
	</head>
	<body>
	
		<canvas class="zdog-canvas" width="240" height="240"></canvas>
<a href="" class="clearButton" id="clear">CLR</a>
		<div id="konsoli"></div>
<script>
function log(msg){
document.getElementById("konsoli").innerHTML+="\n"+msg
}
</script>
<script src="js/deviceorientation.js"></script>
<script>
drawDirection=-1
drawing=false
			deviceOrientationData = null;
devicePos=null
			let isSpinning = true;

			let illo = new Zdog.Illustration({
				element: '.zdog-canvas',
				resize: 'fullscreen'
			});


			
			let rotDummy = new Zdog.Anchor({
				addTo: illo
			});

			function animate(step) {
				
				if(deviceOrientationData!=null){
					var qt=computeQuaternion()
					
					var angles=Quat2Angle(...qt)
					
					if(currentScreenOrientation==0){
					
						illo.rotate.x=drawDirection*angles[2]
						illo.rotate.y=drawDirection*angles[1]
						illo.rotate.z=drawDirection*angles[0]
					}
					else if(currentScreenOrientation==-90){					
						illo.rotate.x=-angles[0]
						illo.rotate.y=angles[1]
						illo.rotate.z=-angles[2]
					}
					else if(currentScreenOrientation==90){					
						illo.rotate.x=angles[0]
						illo.rotate.y=angles[1]
						illo.rotate.z=-angles[2]
					}					
					
					/*
					frame=Math.floor(step/20)%illo.children.length;
					for(var i=3;i<illo.children.length;i++){
						var child=illo.children[i]
						child.visible=(!child.guide)?(i>frame && !child.drawing)?false:true:true
					}
					*/
					illo.updateRenderGraph();
				}
				requestAnimationFrame( animate );
			}
			animate()



Number.prototype.mod = function(n) {
    return ((this%n)+n)%n;
};

function vecLength(vec){
	return Math.sqrt(Math.pow(vec.x,2),Math.pow(vec.y,2))
}

//world axis
var grid = illo.width
var axisColors=["#F00","#0F0","#00F"]

for(var i=0;i<3;i++){
	var axis=new Zdog.Shape({
		addTo: illo,
		path: [{ x: 0, y: 0, z:  0},{ x: (i==0)?grid:0, y: (i==1)?grid:0, z: (i==2)?grid:0 }],
		closed: false,
		stroke: 0.5,
		color: axisColors[i],
	});
	axis.guide=true
}	



var colors=['#EE6621','#EEAA00','#663366']

downCount=0
zCount=-1

prevX=0
prevY=0
x=0
y=0
prevDX=0
prevDY=0
prevDZ=0
devX=0
devY=0
devZ=0
prevPosi={x:0,y:0,z:0}
posi={x:0,y:0,z:0}

function clamp(val,min,max){
    return Math.max(
        min, Math.min(max,val)
    )
}

var dragger=new Zdog.Dragger({
	startElement: '.zdog-canvas',
  onDragStart(e) {
drawing=true
		dragCount=0
		drawDirection=-1
		prevX=x
		prevY=y
prevDX=0
prevDY=0
prevDZ=0
devX=0
devY=0
devZ=0
prevPosi={x:0,y:0,z:0}
posi={x:0,y:0,z:0}
			
		x=e.clientX-illo.width/2
		y=e.clientY-illo.height/2
		/*
		var pt={
			x:x*Math.cos(-illo.rotate.z)-y*Math.sin(-illo.rotate.z),
			y:y*Math.cos(-illo.rotate.z)+x*Math.sin(-illo.rotate.z)
		}
		*/
if(devicePos!=null)var posi={x:x+devicePos.x,y:y+devicePos.y,z:devicePos.z}
else var posi={x:x,y:y,z:0}
		this.shape=new Zdog.Shape({
			addTo: illo,
			path:[
				posi
			],
			rotate:{x:-illo.rotate.x,y:-illo.rotate.y},
			stroke: Math.max(4,e.force*60),
			closed: false,
			color: e.radiusX>25?'#FFF':colors[downCount%colors.length]
		});
		downCount++
		//this.shape.drawing=true
		illo.updateRenderGraph();
  },
  onDragMove(e) {
		//console.log(e)
		
		prevX=x
		prevY=y
prevDX=devX
prevDY=devY
prevDZ=devZ
		
devX=devicePos.x
devY=devicePos.y
devZ=devicePos.z
		x=e.clientX-illo.width/2
		y=e.clientY-illo.height/2
		/*
		var pt={
			x:x*Math.cos(-illo.rotate.z)-y*Math.sin(-illo.rotate.z),
			y:y*Math.cos(-illo.rotate.z)+x*Math.sin(-illo.rotate.z)
		}
		*/
if(devicePos!=null){
var prevPosi={x:prevX+prevDX,y:prevY+prevDY,z:prevDZ}
 var posi={x:x+devX,y:y+devY,z:devZ}
}
else {
var prevPosi={x:prevX,y:prevY,z:0}
 var posi={x:x,y:y,z:0}
}
		this.shape=new Zdog.Shape({
			addTo: illo,
			path:[
				prevPosi,posi
			],
			rotate:{x:-illo.rotate.x,y:-illo.rotate.y},
			stroke: Math.max(4,e.force*60),
			closed: false,
			color:  e.radiusX>25?'#FFF':colors[downCount%colors.length]
		});
		
		//this.shape.drawing=true

		//this.shape.path.push({x:x,y:y,z:0})
		//this.shape.updatePath()

		illo.updateRenderGraph();
		dragCount++
  },
  onDragEnd(){
drawDirection=-1
drawing=false
  		/*
			for(var i=3;i<illo.children.length;i++){
				illo.children[i].drawing=false
			}  	
			*/
  }

});

			
document.getElementById("clear").addEventListener("click",function(e){
e.preventDefault()
for(var i=3;i<illo.children.length;i++){
illo.children[i].remove()
}  	

})

/*			
			var dragger=new Zdog.Dragger({
				startElement: '.zdog-canvas',
				onDragStart(e){
					prevX = e.clientX
					prevY = e.clientY
					currX = e.clientX
					currY = e.clientY
				},
				onDragMove(e,x,y) {
					prevX=currX
					prevY=currY
					currX=e.clientX
					currY=e.clientY
					var deltaX=currX-prevX
					var deltaY=currY-prevY
					rotDummy.rotate.x-=deltaY/100
					rotDummy.rotate.y-=deltaX/100
					illo.updateRenderGraph();
				}
			});
*/			
		</script>

	</body>
</html>
